package nf

import (
	"bufio"
	"encoding/json"
	"fmt"
	"github.com/go-openapi/spec"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"reflect"
	"strings"
)

// GenerateSwaggerJSON 生成完整的 Swagger JSON
func (f *APIFramework) GenerateSwaggerJSON() (string, error) {
	swagger := &spec.Swagger{
		SwaggerProps: spec.SwaggerProps{
			Swagger: "2.0",
			Info: &spec.Info{
				InfoProps: spec.InfoProps{
					Title:       "API Documentation",
					Description: "API documentation generated by the framework",
					Version:     "1.0.0",
				},
			},
			Paths:       new(spec.Paths),
			Definitions: spec.Definitions{},
		},
	}

	swagger.Paths = new(spec.Paths)
	swagger.Paths.Paths = make(map[string]spec.PathItem)

	for _, def := range f.definitions {
		path := swagger.Paths.Paths[def.Meta.Path]
		operation := &spec.Operation{
			OperationProps: spec.OperationProps{
				Summary:     def.Meta.Summary,
				Description: def.Meta.Summary,
				Tags:        strings.Split(def.Meta.Tags, ","),
				Parameters:  f.generateParameters(def.RequestType),
				Responses:   f.generateResponses(def.ResponseType),
			},
		}

		switch strings.ToUpper(def.Meta.Method) {
		case "GET":
			path.Get = operation
		case "POST":
			path.Post = operation
		case "PUT":
			path.Put = operation
		case "DELETE":
			path.Delete = operation
		}

		swagger.Paths.Paths[def.Meta.Path] = path

		// 生成请求和响应的模型定义
		f.generateModelDefinition(swagger, def.RequestType, def.HandlerName+"Request")
		f.generateModelDefinition(swagger, def.ResponseType, def.HandlerName+"Response")
	}

	// 将 Swagger 规范转换为 JSON
	swaggerJSON, err := json.MarshalIndent(swagger, "", "  ")
	if err != nil {
		return "", fmt.Errorf("error marshaling Swagger JSON: %v", err)
	}

	return string(swaggerJSON), nil
}

// generateParameters 生成 Swagger 参数定义
func (f *APIFramework) generateParameters(reqType reflect.Type) []spec.Parameter {
	var parameters []spec.Parameter
	reqType = reqType.Elem() // 因为我们使用指针类型

	for i := 0; i < reqType.NumField(); i++ {
		field := reqType.Field(i)
		if field.Anonymous {
			continue // 跳过匿名字段（如 Meta）
		}

		jsonTag := field.Tag.Get("json")
		if jsonTag == "" {
			jsonTag = strings.ToLower(field.Name)
		}

		param := spec.Parameter{
			ParamProps: spec.ParamProps{
				Name:        jsonTag,
				In:          "query", // 默认为 query 参数，可以根据需要修改
				Description: field.Tag.Get("description"),
				Required:    strings.Contains(field.Tag.Get("v"), "required"),
			},
			SimpleSchema: spec.SimpleSchema{
				Type: f.getSwaggerType(field.Type),
			},
		}
		parameters = append(parameters, param)
	}

	return parameters
}

// generateResponses 生成 Swagger 响应定义
func (f *APIFramework) generateResponses(respType reflect.Type) *spec.Responses {
	return &spec.Responses{
		ResponsesProps: spec.ResponsesProps{
			StatusCodeResponses: map[int]spec.Response{
				200: {
					ResponseProps: spec.ResponseProps{
						Description: "Successful response",
						Schema: &spec.Schema{
							SchemaProps: spec.SchemaProps{
								Ref: spec.MustCreateRef("#/definitions/" + respType.Elem().Name()),
							},
						},
					},
				},
			},
		},
	}
}

// generateModelDefinition 生成模型定义
func (f *APIFramework) generateModelDefinition(swagger *spec.Swagger, modelType reflect.Type, name string) {
	modelType = modelType.Elem() // 因为我们使用指针类型
	properties := make(map[string]spec.Schema)

	for i := 0; i < modelType.NumField(); i++ {
		field := modelType.Field(i)
		if field.Anonymous {
			continue
		}

		jsonTag := field.Tag.Get("json")
		if jsonTag == "" {
			jsonTag = strings.ToLower(field.Name)
		}

		properties[jsonTag] = spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type:        []string{f.getSwaggerType(field.Type)},
				Description: field.Tag.Get("description"),
			},
		}
	}

	swagger.Definitions[name] = spec.Schema{
		SchemaProps: spec.SchemaProps{
			Type:       []string{"object"},
			Properties: properties,
		},
	}
}

// getSwaggerType 将 Go 类型转换为 Swagger 类型
func (f *APIFramework) getSwaggerType(t reflect.Type) string {
	switch t.Kind() {
	case reflect.Bool:
		return "boolean"
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return "integer"
	case reflect.Float32, reflect.Float64:
		return "number"
	case reflect.String:
		return "string"
	case reflect.Slice:
		return "array"
	case reflect.Struct:
		return "object"
	default:
		return "string" // 默认为字符串类型
	}
}

func (f *APIFramework) saveSwaggerJSON() {
	// 生成 Swagger JSON
	swaggerJson, err := f.GenerateSwaggerJSON()
	if err != nil {
		log.Fatalf("Error generating Swagger JSON: %v", err)
	}
	log.Println("swaggerJson:", swaggerJson)
	// 获取当前工作目录
	currentDir, err := os.Getwd()
	if err != nil {
		fmt.Println("Error getting current directory:", err)
		return
	}

	// 文件名
	fileName := "doc.json"

	// 完整的文件路径
	fullFilePath := filepath.Join(currentDir, fileName)

	// 打开文件，如果文件不存在则创建它
	file, err := os.Create(fullFilePath)
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	defer file.Close() // 确保在函数结束时关闭文件
	// 使用bufio.NewWriter来创建一个写入缓冲
	writer := bufio.NewWriter(file)
	defer writer.Flush() // 确保在函数结束时刷新缓冲

	// 写入字符串到文件
	_, err = writer.WriteString(swaggerJson)
	if err != nil {
		fmt.Println("Error writing to file:", err)
		return
	}
	// 显式刷新缓冲区，确保数据写入文件
	err = writer.Flush()
	if err != nil {
		fmt.Println("Error flushing buffer to file:", err)
		return
	}

	fmt.Printf("String successfully written to %s\n", fullFilePath)
}

// addSwaggerPath 添加路径到 Swagger 规范
func (f *APIFramework) addSwaggerPath(def APIDefinition) {
	path := f.swaggerSpec.Paths.Paths[def.Meta.Path]
	operation := &spec.Operation{
		OperationProps: spec.OperationProps{
			Summary:     def.Meta.Summary,
			Description: def.Meta.Summary,
			Tags:        strings.Split(def.Meta.Tags, ","),
			Parameters:  f.getSwaggerParams(def.RequestType),
			Responses:   f.getSwaggerResponses(def.ResponseType),
		},
	}

	switch strings.ToUpper(def.Meta.Method) {
	case "GET":
		path.Get = operation
	case "POST":
		path.Post = operation
	case "PUT":
		path.Put = operation
	case "DELETE":
		path.Delete = operation
	}

	f.swaggerSpec.Paths.Paths[def.Meta.Path] = path
}

// getSwaggerParams 从请求类型生成 Swagger 参数
func (f *APIFramework) getSwaggerParams(reqType reflect.Type) []spec.Parameter {
	var params []spec.Parameter
	for i := 0; i < reqType.Elem().NumField(); i++ {
		field := reqType.Elem().Field(i)
		if field.Anonymous {
			continue
		}
		param := spec.Parameter{
			ParamProps: spec.ParamProps{
				Name:        field.Tag.Get("json"),
				In:          "query",
				Description: field.Tag.Get("description"),
				Required:    strings.Contains(field.Tag.Get("v"), "required"),
			},
			SimpleSchema: spec.SimpleSchema{
				Type: field.Type.String(),
			},
		}
		params = append(params, param)
	}
	return params
}

// getSwaggerResponses 从响应类型生成 Swagger 响应
func (f *APIFramework) getSwaggerResponses(respType reflect.Type) *spec.Responses {
	return &spec.Responses{
		ResponsesProps: spec.ResponsesProps{
			StatusCodeResponses: map[int]spec.Response{
				200: {
					ResponseProps: spec.ResponseProps{
						Description: "Successful response",
						Schema: &spec.Schema{
							SchemaProps: spec.SchemaProps{
								Type: []string{"object"},
							},
						},
					},
				},
			},
		},
	}
}

// serveSwaggerSpec 提供 Swagger 规范 JSON
func (f *APIFramework) serveSwaggerSpec(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(f.swaggerSpec)
}
